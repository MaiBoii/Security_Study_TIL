# 병렬(병행)프로그래밍 학습 중요성

결론부터 말하자면 프로그래밍 작업은 운영체제에 대한 지식과 실행흐름에 대한 이해를 바탕으로 진행되어야 양질의 결과물이 나오기 때문임.

특히 백엔드 쪽에서 스레드, 스케줄러 부하가 큰 작업을 다룰 때 (ex.인터넷 뱅킹, 증시 현황)에는 해당 지식이 더더욱 절실해짐. 

## 프로세스 vs 스레드 차이

### 프로세스 
- 운영체제에서 할당받는 최소한의 자원 단위를 뜻함. 
- CPU 동작 시간, 주소 공간이 서로 독립적임.
- Code,Data,Stack,Heap 각 메모리 영역들이 서로 독립적임.
- 최소 1개의 메인 스레드를 보유함. 
- 메모리가 서로 독립적이지만, 파이프, 파일, 소켓 등의 기술들로 프로세스 간 통신 가능 (그런데 비용이 큼) 전문용어로 Context Switching이라고 함

### 스레드 
- 프로세스 내의 실행 흐름 단위임. 
- 그러니 당연히 프로세스 내의 자원을 사용함.
- Stack만 별도로 사용하고, 나머지 메모리 영역(Code, Data, Heap)은 자기들끼리 공유함. (변수 공유)
- 한 스레드의 결과가 다른 스레드에게 영향을 미침.
    - 그래서 동기화 문제는 정말로 주의해야함. (디버깅이 힘듦.)

### 멀티 스레드 
- 한 개의 단일 어플리케이션에서 여러 스레드로 구성 후 작업을 처리하는 것
- 그러니 시스템 자원이 덜 소모됨 (효율성, 처리량 증가)
    - 하지만 어떻게 짜느냐에 따라 프로세스 여러 개 돌리는 것보다 더 못할 수도 있음
- 통신부담 감소, 디버깅은 어려워짐, 단일 프로세스에는 효과가 미약할 수 있음. (요새는 CPU 성능이 좋아서), 자원 공유 문제가 생길 수 있음(교착 상태), 프로세스 영향 끼침

### 멀티 프로세스 
- 한 개의 단일 어플리케이션에서 여러 프로세스로 구성 후 작업을 처리하는 것
- 한 개의 프로세스에서 문제 발생 시 확산은 없음. 한 놈만 kill -9 하면 되니깐 
- 캐시 체인지를 활용하며, Cost 비용이 매우 높음 (오버헤드 상승 가능성), 복잡한 통신 방식 사용 



## GIL (Global Interpreter Lock)
- 우리가 가장 자주 쓰는 기본적인 파이썬 인터프리터를 CPython이라고 함.
- 이 CPython 인터프리터가 우리가 쓴 파이썬 코드를 byte code로 바꿔서 실행 시킴.
- 이 과정에서 여러 개의 스레드를 사용할 경우 '단 하나'의 스레드만 객체에 접근할 수 있게 제한해놨음. 이걸 GIL이라고 함.

![alt text](GIL.png)

### Q. 이딴 거 왜 만듦?? 그럼 병렬처리는 어떻게 함?
1. CPython은 객체 참조를 사용해서 메모리를 관리하는데 스레드를 여러 개 운용하면 오류나 충돌이 일어나기 쉬운 구조라서 그럼. (Thread-Safe 문제)
2. 단일 스레드 써도 충분히 빠름 
3. 멀티 프로세스 써도 GIL 바깥 영역에서 효율적인 코딩 가능함.
4. 병렬 처리는 Multiprocessing, asyncio 등 선택지 다양함.
5. thread 동시성 구현을 위해서 Jython, IronPython 등 다른 인터프리터들도 사용 가능함. 

### Q. 어? 그럼 저번에 내가 썼던 threading 모듈은 뭐였지?
1. threading은 OS 스레드를 생성함.
- 내부적으로는 C 언어의 pthread (POSIX thread)나 Windows 스레드를 사용해서 실제 OS 수준의 스레드를 만듦.
- 그러니까 멀티스레드인 거는 맞긴 함! 하지만...

2. CPython의 GIL이 모든 스레드의 실행을 순차화함.
- 한 순간에 하나의 스레드만 바이트코드를 실행할 수 있게 함.

3. 스레드는 **짧은 시간마다 GIL을 양보(switch)**하면서 돌아가게 됨. (보통 5ms 단위).
- 그러니 엄밀히 말하자면 이게 병렬 실행같아 보여도 ㄹㅇ 진짜 병렬은 아닌거임.